// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: posts.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPost = `-- name: CreatePost :one
INSERT INTO posts (title, description, content, slug, thumbnail_url, user_id)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, title, content, thumbnail_url, user_id, created_at, updated_at
`

type CreatePostParams struct {
	Title        string `json:"title"`
	Description  string `json:"description"`
	Content      string `json:"content"`
	Slug         string `json:"slug"`
	ThumbnailUrl string `json:"thumbnail_url"`
	UserID       int32  `json:"user_id"`
}

type CreatePostRow struct {
	ID           int32            `json:"id"`
	Title        string           `json:"title"`
	Content      string           `json:"content"`
	ThumbnailUrl string           `json:"thumbnail_url"`
	UserID       int32            `json:"user_id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (CreatePostRow, error) {
	row := q.db.QueryRow(ctx, createPost,
		arg.Title,
		arg.Description,
		arg.Content,
		arg.Slug,
		arg.ThumbnailUrl,
		arg.UserID,
	)
	var i CreatePostRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.ThumbnailUrl,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec
DELETE
FROM posts
WHERE slug = $1
`

func (q *Queries) DeletePost(ctx context.Context, slug string) error {
	_, err := q.db.Exec(ctx, deletePost, slug)
	return err
}

const getPost = `-- name: GetPost :one
SELECT p.id,
       p.title,
       p.description,
       p.content,
       p.slug,
       p.thumbnail_url,
       p.user_id,
       p.created_at,
       p.updated_at,
       u.name AS author_name,
       array_agg(c.name) AS categories
FROM posts p
         JOIN users u ON p.user_id = u.id
         LEFT JOIN postcategories pc ON p.id = pc.post_id
         LEFT JOIN categories c ON pc.category_id = c.id
WHERE p.slug = $1
GROUP BY p.id, u.name
LIMIT 1
`

type GetPostRow struct {
	ID           int32            `json:"id"`
	Title        string           `json:"title"`
	Description  string           `json:"description"`
	Content      string           `json:"content"`
	Slug         string           `json:"slug"`
	ThumbnailUrl string           `json:"thumbnail_url"`
	UserID       int32            `json:"user_id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	AuthorName   string           `json:"author_name"`
	Categories   interface{}      `json:"categories"`
}

func (q *Queries) GetPost(ctx context.Context, slug string) (GetPostRow, error) {
	row := q.db.QueryRow(ctx, getPost, slug)
	var i GetPostRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Content,
		&i.Slug,
		&i.ThumbnailUrl,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuthorName,
		&i.Categories,
	)
	return i, err
}

const listPosts = `-- name: ListPosts :many
SELECT p.id,
       p.title,
       p.description,
       p.slug,
       p.thumbnail_url,
       p.user_id,
       p.created_at,
       p.updated_at,
       u.name AS author_name,
       array_agg(c.name) AS categories
FROM posts p
         JOIN users u ON p.user_id = u.id
         LEFT JOIN postcategories pc ON p.id = pc.post_id
         LEFT JOIN categories c ON pc.category_id = c.id
GROUP BY p.id, u.name
ORDER BY p.created_at DESC
LIMIT $1 OFFSET $2
`

type ListPostsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListPostsRow struct {
	ID           int32            `json:"id"`
	Title        string           `json:"title"`
	Description  string           `json:"description"`
	Slug         string           `json:"slug"`
	ThumbnailUrl string           `json:"thumbnail_url"`
	UserID       int32            `json:"user_id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	AuthorName   string           `json:"author_name"`
	Categories   interface{}      `json:"categories"`
}

func (q *Queries) ListPosts(ctx context.Context, arg ListPostsParams) ([]ListPostsRow, error) {
	rows, err := q.db.Query(ctx, listPosts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPostsRow
	for rows.Next() {
		var i ListPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Slug,
			&i.ThumbnailUrl,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorName,
			&i.Categories,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePost = `-- name: UpdatePost :one
UPDATE posts
SET title         = $1,
    content       = $2,
    slug          = $3,
    thumbnail_url = $4,
    updated_at    = CURRENT_TIMESTAMP
WHERE slug = $5
RETURNING id, title, description, content, slug, thumbnail_url, user_id, created_at, updated_at
`

type UpdatePostParams struct {
	Title        string `json:"title"`
	Content      string `json:"content"`
	Slug         string `json:"slug"`
	ThumbnailUrl string `json:"thumbnail_url"`
	Slug_2       string `json:"slug_2"`
}

type UpdatePostRow struct {
	ID           int32            `json:"id"`
	Title        string           `json:"title"`
	Description  string           `json:"description"`
	Content      string           `json:"content"`
	Slug         string           `json:"slug"`
	ThumbnailUrl string           `json:"thumbnail_url"`
	UserID       int32            `json:"user_id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (UpdatePostRow, error) {
	row := q.db.QueryRow(ctx, updatePost,
		arg.Title,
		arg.Content,
		arg.Slug,
		arg.ThumbnailUrl,
		arg.Slug_2,
	)
	var i UpdatePostRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Content,
		&i.Slug,
		&i.ThumbnailUrl,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
